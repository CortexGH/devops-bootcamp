---
docs/7-infrastructure-configuration-management/7.1.4-terraform-providers.md:
  category: Infrastructure as Code
  estReadingMinutes: 20
  exercises: 
    -
      name: Provider Boilerplate
      description: Set up the boilerplate for a Terraform provider and test it locally.
      estMinutes: 120
      technologies:
      - Terraform
      - Go
    -
      name: Implementing the provider client
      description: Implement the Terraform provider client to interact with a custom API.
      estMinutes: 240
      technologies:
      - Terraform
      - Go
---

# Terraform Providers

At this point, you should have a good grasp on declaratively defining infrastructure as code and managing the state of that infrastructure using Terraform. Now, let's pull back the curtain and see how Terraform works.

So far, we've seen Terraform manage resources in different places, such as AWS and Azure. How does Terraform manage to communicate with both of these platforms?

All resources and datasources in Terraform are created by a **provider**. Providers are Terraform plugins that define how resources are declared and how the state of those  resources should be reconciled. Anyone can write a Terraform provider, and providers can be shared publically or privately via provider repositories. This extensibility of part of what makes Terraform so powerful. 

?> Take a look at the providers that are published to the [official Terraform repository](https://registry.terraform.io/browse/providers)

### The DevOps API

Most of the time, you'll be able to find a Terraform provider for the platform you're hosting your infrastructure on. However, for this section, we have an API who's resources we want to manage with Terraform. The DevOps API (created by the Ferrets apprentice wave using a web framework called [GIN](https://github.com/gin-gonic/gin)) is an ephemeral API and has the following resources:

``` bash
1. Engineer - an individual engineer
    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - email (string: valid email address format)

2. Developer - a collection of developer engineers
    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - engineers (list of engineer resources)

3. Operations - a collection of operations engineers
    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - engineers (list of engineer resources)

4. DevOps - a combination of a collection of developer and operations engineers
    - id (unique numeric or alphanumeric identifier)
    - dev (dev resources)
    - ops (ops resource)
```

Since this is a custom API the Ferrets have written, we will also need to make our own custom Terraform provider if we want to use Terraform to manage our resources. Knowing the structure of this API is crucial when attempting to write the provider. Before diving into creating the provider for this API, take some time looking over the [API ReadMe](https://github.com/liatrio/devops-bootcamp/blob/7a7b695f669f13a6894bad2220cf34d5a8785d09/examples/ch6/devops-api/README.md), as well as the accompanying scripts. Try to run the API locally and add some resources until you think you have a good understanding of how it works. 

<div id="quizdown">
    <div id="chapter-7/section-4/api-checkpoint.js" ></div>
</div>

Now that we have a grasp on what it is we're attempting to have Terraform manage, we can start a deeper discussion of how we can write a Terraform provider to declaratively manage our resources within this API.

### Exercise 1: Provider Boilerplate

Creating a Terraform provider is hard. To help mitigate some of the difficulty, Hashicorp provides some boilerplate code to help you get started. 

1. Create your own repo containing the Hashicorp provided boilerplate code from their template. 
    - To do this, navigate to the [terraform-provider-scaffolding](https://github.com/hashicorp/terraform-provider-scaffolding-framework) repo, click "Use this template", "Create a new repository", and fill in the required information (owner and repo name). If you're working as a group on this, make sure to also add each group member as a collaborator.

2. Clone your repo. Navigate to `main.go` and change the provider address from `registry.terraform.io/hashicorp/scaffolding` to `liatr.io/terraform/devops-bootcamp`.

3. Delete the provided `GNUmakefile` and replace it with [this updated Makefile](https://github.com/liatrio/devops-bootcamp/blob/4503cf73612b1e5be73e4f9d13717d0e157c4d0f/examples/ch6/provider-setup/Makefile) and [helper script](https://github.com/liatrio/devops-bootcamp/blob/7364553501872567fe105dc27f3cf84dd3a11cf8/examples/ch6/provider-setup/.make-helper.sh). Run `make init` to initialize your repo.

4. Ensure that your provider executes correctly by running `go run main.go`. You should see the following output: 
```bash
   This binary is a plugin. These are not meant to be executed directly.
   Please execute the program that consumes these plugins, which will
   load any plugins automatically
   exit status 1
```

5. Create a Terraform module with the following configuration:
```go
    terraform {
      required_providers {
        devops-bootcamp = {
          source = "liatr.io/terraform/devops-bootcamp"
        }
      }
    }

    provider "devops-bootcamp" {
      # example configuration here
    }
```

6. Run `terraform init -plugin-dir=.plugin-cache` to use the provider binary we created in step 3. 

?> What do you think the `-plugin-dir` flag indicates? Why do we need to specify this?

7. Run `terraform plan` to ensure Terraform can find and use your provider.

We now have the base for our provider! Next, well need to actually implement it.

### Schemas, Structs, and Types

Before we can write our provider, there are a few things we need to know about the Terraform provider framework.

Generally, Terraform providers try to adhere to the structure of CRUD operations. This means that providers attempt to classify API functionality into 4 groups:

- C[reate]
    - Creates a new resource
- R[ead]
    - Reads an existing resource
- U[pdate]
    - Updates an existing resource
    - Note that in our API, we can only directly update a resource, and not the resources within it. (eg. You can't update an engineer from its parent dev resource.)
- D[elete]
    - Deletes an existing resource
    - Again, note that in our API, when we delete a parent resource, we do not also delete its children.

In addition to these basic functions, the Terraform provider framework manages data through a schema. A schema defines the metadata and overall "shape" that Terraform can expect to receive when interacting with your API. 

Lastly, you'll need to create two separate sets of data structures to hold your data within your provider code:

1. Structures consisting of plain Go types. You'll need these to construct the payloads you'll be sending to the API.

2. Structures consisting of [Terraform types](https://developer.hashicorp.com/terraform/plugin/framework/handling-data/attributes). These are the types that will be in your schema, and are used to handle the data within your Terraform state and plans.

That's a lot of information to digest, and it might not all make sense right now. That's alright, just make sure to keep this information in mind in the upcoming exercises.

### Exercise 2: Implement Provider Client

With all of that out of the way, it's time to implement our provider! We'll start by implementing our provider client. This will involve setting up the way we'll actually communicate with our API. 

In order to implement our client, we'll be referencing the Hashicorp tutorial ["Configure provider client" section.](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-provider-configure)

A couple of things to keep in mind:

- The Hashicorp tutorial implements their "Hashicup" API. Since our API isn't identical to theirs, you'll need to adapt some of the code they give you to match with our API.

- Since they're implementing a different API, you might not need everything they do. When they're implementing something, think about why they're implementing it in the way they are, and if this is necessary for your API.
    - A good example of this is authentication credentials. The Hashicorp tutorial defines authentication and host information. Do you need to authenticate to our API? How do you interact with/reach our API?

With these notes in mind, follow the "Configure provider client" section of the Hashicorp tutorial to implement your devops-api client, and return here once you've finished. It might also be helpful to reference the `Schemas, Structs, and Types` portion of this section while working through the tutorial.

?> If you're unsure of how to adapt the tutorial to our API, it might be helpful to walk through the tutorial using the Hashicups API first.

### Implement the engineer data source

### Implement the engineer resource

### Go back and implement one other resource to ensure comprehension